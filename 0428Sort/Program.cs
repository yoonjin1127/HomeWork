namespace _0428Sort
{
    internal class Program
    {
        /***********************
         * 선형 정렬
         * 
         * 1개의 요소를 재위치시키기 위해 전체를 확인하는 정렬
         * n개의 요소를 재위치시키기 위해 n개를 확인하는 정렬
         * 시간복잡도 : O(N^2)
         * 
         * 분할정복에 비해 속도가 느림
          
         

           1. <선택정렬 (Selection Sort)>
        // 데이터 중 가장 작은 값부터 하나씩 선택하여 정렬
        // 가장 작은 값을 0번째 값과 교체, 그 다음으로 작은 값을 1번째 값과 교체...를 반복

           2. <삽입정렬 (Insertion Sort)>
        // 데이터를 하나씩 꺼내어 정렬된 자료 중 적합한 위치에 삽입하여 정렬
        // 가장 작은 수를 맨 앞으로 한 칸씩 밀어올림
        // 한 사람씩 양해를 구하고 맨 앞으로 이동하는 것과 유사함

           3. <버블정렬 (Bubble Sort)>
        // 서로 인접한 데이터를 비교하여 정렬
        // 계속해서 큰 걸 뒤로 밀어냄
        // LinkedList같은 연결리스트에서도 사용이 가능하다 (분할정복에서는 불가능)

        ****************************/




        /*****************************
         * 분할정복 정렬
         * 
         * 1개의 요소를 재위치시키기 위해 전체의 1/2를 확인하는 정렬
         * n개의 요소를 재위치시키기 위해 n/2개를 확인하는 정렬
         * 시간복잡도 : O(NlogN)
         

           [캐시]
        // 캐시란 프로그램이 수행될 때 나타나는 지역성을 이용하여
        // 메모리나 디스크에서 사용되었던 내용을 특별히 빠르게 접근할 수 있는 곳에 보관하고 관리함으로써,
        // 이 내용을 다시 필요로 할 때 보다 빠르게 참조하도록 하는 것이다.
        // 즉, '사용되었던 데이터는 다시 사용될 가능성이 높다'는 개념을 이용한 것이다.
        // 다시 사용될 확률이 높은 아이들을 좀 더 빠르게 접근 가능한 저장소를 사용한다는 개념이다.

           [컴퓨터의 참조 지역성 원리 ~퀵정렬이 힙정렬보다 빠른 이유~]
        // 힙 정렬의 경우 불러오기, 재조정 과정을 반복해야 하기 때문에 (원소 임의 접근)
        // 메모리 영역, 즉 캐시에 부담을 줘서 참조지역성의 특성을 활용한 캐시의 성능 가속을 얻기 어려움
        // 그렇기에 실제로는 퀵 정렬(인접한 원소 접근)보다 느릴 수 있음



           1. <힙 정렬 (Heap Sort)
        // 힙(우선순위 큐)을 이용하여 우선순위가 가장 높은 요소부터 가져와 정렬
        // 같은 숫자끼리도 규칙을 지켜 다르게 취급하는 힙의 특성 때문에 불안정 정렬(깨지는 정렬)

           2. <합병정렬 (Mergy Sort)
        // 데이터를 2분할하여 정렬 후 합병
        // 큰 덩어리를 반절로 나누는 걸 가능할 때까지 반복하고, 정렬 후 다시 붙임
        // 다른 정렬과 다르게 메모리적 부담이 있음(메모리를 희생하고 시간을 얻음)

           3. <퀵 정렬 (Quick Sort)>
        // 하나의 피벗을 기준으로 작은 값과 큰 값을 2분할하여 정렬
        // 교체를 하는 것이지, 따로 배열을 생성하지는 않기 때문에 추가적 메모리 사용은 없음
        // 그러나 최악의 경우 시간복잡도 O(n^2)      (ex: 5 4 3 2 1 같은 역순 배열에서)
        // 불안정 정렬(깨지는 정렬)


        [퀵 정렬의 구체적인 과정]

        1단계. 분할(Divide) : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽 = 피벗보다 작은 요소들, 오른쪽 = 피벗보다 큰 요소들)로 분할한다.

        2단계. 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.

        3단계. 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.

        - 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다. 
   
        [퀵 정렬의 동작원리]

        1. 리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗(pivot - 기준점을 의미하기 떄문에 다르게 불러도 된다. 다만 피벗이라 많이 칭함)이라고 한다.

        2. 피벗 앞에는 피봇보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 이렇게 리스트를 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
                                                                                                                                                                                                                                                        
        3. 분할된 두 개의 작은 리스트에 대해 재귀적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.
     

       

         ******************************/
    }
}